/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export class SDK extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }
    async searchCryptoByName(
        name?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.SearchCryptoByNameResponse> {
        const input$: operations.SearchCryptoByNameRequest = {
            name: name,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.SearchCryptoByNameRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/search")();

        const query$ = [
            enc$.encodeForm("name", payload$.name, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.SearchCryptoByNameResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get Portfolio
     */
    async fetchWalletNFTs(
        wallet?: string | undefined,
        force?: boolean | undefined,
        blockchains?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchWalletNFTsResponse> {
        const input$: operations.FetchWalletNFTsRequest = {
            wallet: wallet,
            force: force,
            blockchains: blockchains,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchWalletNFTsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/wallet/nfts")();

        const query$ = [
            enc$.encodeForm("blockchains", payload$.blockchains, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("force", payload$.force, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("wallet", payload$.wallet, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchWalletNFTsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get all crypto data with extra fields as needed
     */
    async fetchAllCryptoDetails(
        fields?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchAllCryptoDetailsResponse> {
        const input$: operations.FetchAllCryptoDetailsRequest = {
            fields: fields,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchAllCryptoDetailsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/all")();

        const query$ = [
            enc$.encodeForm("fields", payload$.fields, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchAllCryptoDetailsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get the market metrics for any asset
     */
    async fetchAssetMarketData(
        asset?: string | undefined,
        blockchain?: string | undefined,
        symbol?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchAssetMarketDataResponse> {
        const input$: operations.FetchAssetMarketDataRequest = {
            asset: asset,
            blockchain: blockchain,
            symbol: symbol,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchAssetMarketDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/data")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchain", payload$.blockchain, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("symbol", payload$.symbol, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchAssetMarketDataResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get the market metrics for any DEX pair
     */
    async fetchPairMarketData(
        address: string,
        blockchain?: string | undefined,
        asset?: any | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchPairMarketDataResponse> {
        const input$: operations.FetchPairMarketDataRequest = {
            address: address,
            blockchain: blockchain,
            asset: asset,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchPairMarketDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/pair")();

        const query$ = [
            enc$.encodeForm("address", payload$.address, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchain", payload$.blockchain, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchPairMarketDataResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Fetch all DEX pairs from a specific asset
     */
    async fetchPairsMarketData(
        asset: string,
        blockchain?: string | undefined,
        offset?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchPairsMarketDataResponse> {
        const input$: operations.FetchPairsMarketDataRequest = {
            asset: asset,
            blockchain: blockchain,
            offset: offset,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchPairsMarketDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/pairs")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchain", payload$.blockchain, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("offset", payload$.offset, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchPairsMarketDataResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get the market metrics of an asset over a given timeframe
     */
    async fetchAssetMarketHistory(
        asset: string,
        blockchain?: string | undefined,
        from?: number | undefined,
        to?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchAssetMarketHistoryResponse> {
        const input$: operations.FetchAssetMarketHistoryRequest = {
            asset: asset,
            blockchain: blockchain,
            from: from,
            to: to,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchAssetMarketHistoryRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/history")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchain", payload$.blockchain, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("from", payload$.from, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("to", payload$.to, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchAssetMarketHistoryResponse$.inboundSchema.parse({
                ...responseFields$,
                MarketHistoryResponse: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async fetchMultipleAssetMarketData(
        assets?: string | undefined,
        blockchains?: string | undefined,
        symbols?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchMultipleAssetMarketDataResponse> {
        const input$: operations.FetchMultipleAssetMarketDataRequest = {
            assets: assets,
            blockchains: blockchains,
            symbols: symbols,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ =
            operations.FetchMultipleAssetMarketDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/multi-data")();

        const query$ = [
            enc$.encodeForm("assets", payload$.assets, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchains", payload$.blockchains, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("symbols", payload$.symbols, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchMultipleAssetMarketDataResponse$.inboundSchema.parse({
                ...responseFields$,
                MultiDataResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Retrieve trade history for a given asset.
     */
    async fetchAssetTradeHistory(
        asset: string,
        maxResults?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchAssetTradeHistoryResponse> {
        const input$: operations.FetchAssetTradeHistoryRequest = {
            asset: asset,
            maxResults: maxResults,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchAssetTradeHistoryRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/market/trades")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("maxResults", payload$.maxResults, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchAssetTradeHistoryResponse$.inboundSchema.parse({
                ...responseFields$,
                TradeHistoryResponse: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 400, "application/json")) {
            const responseBody = await response.json();
            const result = errors.ErrorResponse$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async fetchAssetMetadata(
        asset: string,
        blockchain?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchAssetMetadataResponse> {
        const input$: operations.FetchAssetMetadataRequest = {
            asset: asset,
            blockchain: blockchain,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchAssetMetadataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/metadata")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchain", payload$.blockchain, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchAssetMetadataResponse$.inboundSchema.parse({
                ...responseFields$,
                Asset: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Swap
     */
    async fetchSwapQuote(
        input: operations.FetchSwapQuoteRequest,
        options?: RequestOptions
    ): Promise<operations.FetchSwapQuoteResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchSwapQuoteRequest$.outboundSchema.parse(input);
        const body$ = null;

        const path$ = this.templateURLComponent("/quote")();

        const query$ = [
            enc$.encodeForm("amount", payload$.amount, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("chain", payload$.chain, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("fromAddress", payload$.fromAddress, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("fromToken", payload$.fromToken, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("receiver", payload$.receiver, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("slippage", payload$.slippage, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("toToken", payload$.toToken, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("type", payload$.type, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchSwapQuoteResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get the historical balance of any EVM-compatible wallets, at any time
     */
    async fetchWalletHistoryBalance(
        wallet: string,
        from?: number | undefined,
        to?: number | undefined,
        blockchains?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchWalletHistoryBalanceResponse> {
        const input$: operations.FetchWalletHistoryBalanceRequest = {
            wallet: wallet,
            from: from,
            to: to,
            blockchains: blockchains,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchWalletHistoryBalanceRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/wallet/history")();

        const query$ = [
            enc$.encodeForm("blockchains", payload$.blockchains, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("from", payload$.from, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("to", payload$.to, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("wallet", payload$.wallet, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchWalletHistoryBalanceResponse$.inboundSchema.parse({
                ...responseFields$,
                WalletHistoryResponse: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Fetch Wallet Portfolio
     *
     * @remarks
     * Get the portfolio of holdings from any EVM-compatible wallets, at any time
     */
    async fetchWalletHoldings(
        wallet: string,
        blockchains?: string | undefined,
        cache?: boolean | undefined,
        stale?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.FetchWalletHoldingsResponse> {
        const input$: operations.FetchWalletHoldingsRequest = {
            wallet: wallet,
            blockchains: blockchains,
            cache: cache,
            stale: stale,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchWalletHoldingsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/wallet/portfolio")();

        const query$ = [
            enc$.encodeForm("blockchains", payload$.blockchains, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("cache", payload$.cache, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("stale", payload$.stale, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("wallet", payload$.wallet, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchWalletHoldingsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Fetch Wallet Transactions
     *
     * @remarks
     * Retrieve all transactions for a specified wallet within a given timeframe.
     */
    async fetchWalletTransactions(
        input: operations.FetchWalletTransactionsRequest,
        options?: RequestOptions
    ): Promise<operations.FetchWalletTransactionsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.FetchWalletTransactionsRequest$.outboundSchema.parse(input);
        const body$ = null;

        const path$ = this.templateURLComponent("/wallet/transactions")();

        const query$ = [
            enc$.encodeForm("asset", payload$.asset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("blockchains", payload$.blockchains, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("from", payload$.from, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("limit", payload$.limit, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("offset", payload$.offset, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("order", payload$.order, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("to", payload$.to, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("wallet", payload$.wallet, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const response = await this.fetch$(
            { method: "get", path: path$, headers: headers$, query: query$, body: body$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.FetchWalletTransactionsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
